USE MyDatabase;

-- Retrieve All customer data
SELECT 
*
FROM customers;

GO

-- Retrieve All order data

SELECT *
FROM orders;

-- Retrieve EACH customer name, country, and score

SELECT
	first_name,
	country,
	score
FROM customers;

-- Retrieve all customers with scores of 500 and above.
SELECT *
FROM customers
WHERE score >= 500;


-- Retrieve all customers from Germany

SELECT * 
FROM customers
WHERE country = 'Germany';

-- Retrieve all customers in ascending order of there scores and are from Germany.

SELECT *
FROM customers
WHERE country = 'Germany'
ORDER BY score ASC;

-- Retrieve all customers and sort the results by the highest score first

SELECT *
FROM customers
ORDER BY score DESC;

-- Retrieve all customers and sort the results y the country and then by the highest score

SELECT *
FROM customers
ORDER BY country ASC,
 	score DESC;

GO

-- Find the total score for each country.

SELECT 
country,
SUM(score) AS total_score
FROM customers
GROUP BY country;

-- Find the total score and total number of customers for each country

SELECT 
	country,
	SUM(score),
	COUNT(id) AS total_customers
FROM customers
GROUP BY country;
	
-- Find the average score for each country considering only customers with a score not equal to 0

SELECT 
	country,
	AVG(score) AS avg_score
FROM customers
where score != 0
GROUP BY country;



/* Find the average score for each country
	considering only customers with a score not equal to 0
	and return only those with an average score greater than 430
*/

SELECT 
	country,
	AVG(score) AS total_score
FROM customers
WHERE score != 0
GROUP BY country
HAVING AVG(score) > 430;

-- Return unique list of all countries.

SELECT DISTINCT
	country
FROM customers;

-- Retrieve the Top 3 customers.
SELECT TOP 3 *	
FROM customers;

-- Retrieve the Top 3 customers with the highest score

SELECT TOP 3 *
FROM customers
ORDER BY score DESC;



-- Data Definition Language DDL

/*
	CREATE, ALTER & DROP
*/

-- Create a new table called persons with columns: id, person_name, birth_date, and phone.

CREATE TABLE persons (
id INT NOT NULL,
person_name VARCHAR(50) NOT NULL,
birth_date DATE,
phone VARCHAR(15) NOT NULL
CONSTRAINT pk_persons PRIMARY KEY (id)
)

-- Add a new column called email to the persons table

ALTER TABLE persons 
ADD	email VARCHAR(50) NOT NULL

-- Remove the column phone from the persons table

ALTER TABLE persons
DROP COLUMN phone

-- Delete the table persons from the database.

DROP TABLE persons



-- DATA MANIPULATION LANGUAGE DML

/*
	INSERT, UPDATE & DELETE
*/


INSERT INTO customers (id, first_name, country, score)
VALUES 
	(6, 'Anna', 'Kenya', NULL),
	(7, 'Anna', NULL, 100)

SELECT * FROM customers

-- Change the name Sam in id 6 to Anna.

UPDATE customers
SET first_name = 'Anna'
WHERE id = 6

-- Count all the number of customers we have in the table customers.

SELECT 
COUNT (*) FROM customers

-- Copy data from 'customers' table into 'persons'

INSERT INTO persons (id, person_name, birth_date, phone)
SELECT 
id, 
first_name AS  person_name,
NULL,
'Unknown'
FROM customers

-- Change the score of customer 7 to 0 and update the country to UK.

UPDATE customers
SET score = 0,
	country = 'UK'
WHERE id = 7

-- Update all customers with a NULL score by setting their score to 0

UPDATE customers
SET score = 0
WHERE score IS NULL


-- Delete all customers with an ID greater than 5

DELETE FROM customers
WHERE id > 5

select * from customers

-- Delete all from table persons

SELECT * FROM persons

DELETE FROM persons




/*

FILTERING DATA USING 'WHERE'
1. COMPARISON OPERATORS: =, <>, =!, >, >=, <, <=
2. LOGICAL OPERATORS: AND, OR NOT
3. RANGE OPERATOR: BETWEEN
4. MEMBERSHIP OPERATOR: IN, NOT IN
5. SEARCH OPERATOR: LIKE
2:09:24
*/

-- 1. COMPARISON OPERATOR

-- Retrieve all customers from Germany. =
SELECT *
FROM customers
WHERE country = 'Germany'

-- Retrieve all customers who are not from Germany. != or <>
SELECT *
FROM customers
WHERE country != 'Germany'

-- Retrieve all customers with a score greater than 500. >
SELECT *
FROM customers
WHERE score > 500

-- Retrieve all customers with a score of 500 or more. >=
SELECT *
FROM customers
WHERE score >= 500


-- 2. LOGICAL OPERATOR -> AND, OR, NOT

-- Retrieve all customers who are from the USA AND  have a score greater than 500. AND
SELECT *
FROM customers
WHERE country = 'USA' AND score > 500


-- Retrieve all customers who are either from the USA OR  have a score greater than 500. OR
SELECT *
FROM customers
WHERE country = 'USA' OR score > 500

-- Retrieve all customers with a score NOT less than 500. NOT
SELECT *
FROM customers
WHERE NOT score < 500



-- 2. RANGE OPERATOR -> BETWEEN

-- Retrieve all customers whose score falls in the range between 100 and 500
SELECT *
FROM customers
WHERE score BETWEEN 100 AND 500


-- 2. RANGE OPERATOR -> IN, NOT IN

-- Retrieve all customers from either Germany OR USA.

SELECT *
FROM customers
WHERE country IN ('Germany', 'USA')

-- Retrieve all customers who are not from either Germany OR USA.
SELECT *
FROM customers
WHERE country NOT IN ('Germany', 'USA')


-- 3. SEARCH OPERATOR -> LIKE

-- Find all customers whose first name starts with 'M'

SELECT *
FROM customers
WHERE first_name LIKE 'M%'

-- Find all customers whose first name ends with 'n'

SELECT *
FROM customers
WHERE first_name LIKE '%n'


-- Find all customers whose first name contains 'r'

SELECT *
FROM customers
WHERE first_name LIKE '%r%'


-- Find all customers whose first name has 'r' in the third position

SELECT *
FROM customers
WHERE first_name LIKE '__r%'


/*
	COMBINING DATA FROM MULTIPLE TABLES: JOINS & SET OPERATORS

	SQL JOINS
	1. INNER JOIN
	2. LEFT JOIN
	3. RIGHT JOIN
	4. FULL JOIN
	
	ADVANCED CONCEPTS

	5. LEFT ANTI JOIN
	6. RIGHT ANTI JOIN
	7. FULL ANTI JOIN 
	8. CROSS JOIN
*/


-- Retrieve all data from customers and orders as separate results

SELECT TOP(2) * 
FROM customers

SELECT TOP(2) * 
FROM orders

-- 1. INNER JOIN -> Returns only the matching data from both tables

-- Get all customers along with their orders, but only for customers who have placed an order.

SELECT 
	c.id,
	c.first_name,
	c.country,
	c.score,
	o.order_id,
	o.order_date,
	o.sales
FROM customers AS c
INNER JOIN orders AS o
ON id = customer_id;


-- 2. LEFT JOIN -> Returns all rows from left and only matching from right.

-- Get all customers along with their orders, including those without orders.

SELECT 
c.id,
c.first_name,
c.country,
c.score,
o.order_id,
o.order_date,
o.sales
FROM customers AS c
LEFT JOIN orders AS o
ON id = customer_id

-- 3. RIGHT JOIN -> Returns all rows from right and only matching from left.

-- Get all customers along with their orders, including orders without matching customers.

SELECT *
FROM customers
RIGHT JOIN orders
ON id = customer_id


-- 4. FULL JOIN -> Returns all rows from BOTH tables.

-- Get all customers and all orders, even if there's no match

SELECT *
FROM customers
FULL JOIN orders
ON id = customer_id


-- ADVANCED JOINS

-- 1. LEFT ANTI JOIN -> Returns rows from left that has no match in right

-- Get all customers who haven't placed any order.

SELECT *
FROM customers
LEFT JOIN orders
ON id = customer_id
WHERE customer_id IS NULL

-- 2. FULL ANTI JOIN -> Returns ONLY rows that don't match in either tables

-- Find customers without orders and orders without customers.

SELECT *
FROM customers
FULL JOIN orders
ON id = customer_id
WHERE id IS NULL OR customer_id IS NULL

/*
	CHALLENGE
	Get all customers along with their orders, but only for customers 
	who have placed an order without using INNER JOIN

*/

SELECT * 
FROM customers
LEFT JOIN orders
ON id = customer_id
WHERE customer_id IS NOT NULL


-- 3. CROSS JOIN -> Combines every row from left with every row from right. All possible combinations (Cartesian Join)
				

-- Generate all possible combinations of customers and orders.

SELECT * 
FROM customers
CROSS JOIN orders


-- CHALLENGE
/*
-- Using the SalesDB, retrieve a list of all orders, along with the related customer, product, and employee details.
	For each order, display:
		1.Order ID
		2.Customer Name
		3.Product Name
		4.Sales
		5.Price
		6.Sales Person Name
*/
-- SOLUTION

USE SalesDB

SELECT *
FROM Sales.Orders

SELECT *
FROM Sales.Customers

SELECT *
FROM Sales.Products

SELECT *
FROM Sales.Employees

SELECT 
	O.OrderID,
	O.Sales,
	C.FirstName AS CustomerName,
	P.Product,
	P.Price,
	E.FirstName AS SalesPerson
FROM Sales.Orders AS O
LEFT JOIN Sales.Customers AS C
ON O.CustomerID = C.CustomerID
LEFT JOIN Sales.Products AS P
ON O.ProductID = P.ProductID
LEFT JOIN Sales.Employees AS E
ON O.SalesPersonID = E.EmployeeID



/* 
	SET OPERATORS -> Combining Rows

	TYPES
	1. UNION
	2. UNION ALL
	3. EXCEPT (Minus)
	4. INTERSECT

	NB: # NO.of columns has to be the same
		# The data types of each column in each query must match
		# Have the same number of columns and in the same order
		# The column names in the result set are determined by the column names specified in the first query.
		# ORDER BY can be used only once
		# Ensure that you are mapping correct columns

*/

-- EXAMPLE

-- 1. UNION -> Returns all distinct rows from both queries and removes duplicate rows from the result.

SELECT
FirstName,
LastName
FROM Sales.Customers
UNION
SELECT
FirstName,
LastName
FROM Sales.Employees

-- TASK
-- Combine the data from employees and customers into one table.

SELECT 
	FirstName,
	LastName
FROM Sales.Customers
UNION
SELECT 
	FirstName,
	LastName
FROM Sales.Employees

-- 2. UNION ALL -> Returns all rows from both queries including duplicates.
-- Combine the data from employees and customers into one table, including duplicates.

SELECT 
	FirstName,
	LastName
FROM Sales.Customers
UNION ALL
SELECT 
	FirstName,
	LastName
FROM Sales.Employees

-- 3. EXCEPT -> Returns all distinct rows from the first query that are not found in the second query.
-- Find employees who are not customers at the same time.

SELECT 
	FirstName,
	LastName
FROM Sales.Employees
EXCEPT
SELECT 
	FirstName,
	LastName
FROM Sales.Customers

-- 4. INTERSECT -> Returns ONLY the rows that are common in both queries.
-- Find employees who are also customers.

SELECT 
	FirstName,
	LastName
FROM Sales.Employees
INTERSECT
SELECT 
	FirstName,
	LastName
FROM Sales.Customers

/*
	TASK
	=> Orders are stored in separate tables
	(Orders and OrdersArchive).
	Combine all orders into one report without duplicates
*/

-- SOLUTION
SELECT 
'Orders' AS SourceTable,
	OrderID,
	ProductID,
	CustomerID,
	SalesPersonID,
	OrderDate,
	ShipDate,
	OrderStatus,
	ShipAddress,
	BillAddress,
	Quantity,
	Sales,
	CreationTime
FROM Sales.Orders
UNION 
SELECT 
'OrdersArchive' AS SourceTable,
	OrderID,
	ProductID,
	CustomerID,
	SalesPersonID,
	OrderDate,
	ShipDate,
	OrderStatus,
	ShipAddress,
	BillAddress,
	Quantity,
	Sales,
	CreationTime
FROM Sales.OrdersArchive
ORDER BY OrderID


/*

	SQL FUNCTIONS
	-> They are built-in functions that accepts an input
	   value, process it, and returns an output 
	   value

	TYPES OF SQL FUNCTIONS:

	1. ROW-LEVEL FUNCTIONS
	2. AGGREGATION & ANALYTICAL FUNCTIONS


	1. ROW-LEVEL FUNCTIONS ->
		* String Func
		* Number Func
		* Date & Time Func
		* Null Func
		* Case Statement

*/

-- * String Func

-- CONCAT -> Combines multiple strings into one

-- TASK

-- Concatenate first name and country into one column

SELECT 
first_name,
country,
CONCAT(first_name, ' ', country) AS Name_Country
FROM customers

-- LOWER & UPPER -> Converts all characters to upper and vice-versa

-- TASK 
-- Convert the first names of customers to lowercase

SELECT
first_name,
LOWER(first_name) AS LowerName,
country
FROM customers

-- TASK 
-- Convert the first names of customers to uppercase

SELECT
first_name,
UPPER(first_name) AS UpperName,
country
FROM customers

-- TRIM -> Removes leading and trailing spaces
-- TASK
-- Find customers whose first name contains leading or trailing spaces

SELECT 
first_name
FROM customers
WHERE first_name != TRIM(first_name)

-- You can also solve the same problem by finding the length of the names

SELECT 
first_name,
LEN(first_name) AS Len_Names,
LEN(TRIM(first_name)) AS TrimmedNamesLen
FROM customers


-- REPLACE -> Replace specific character with a new character

-- TASK
-- Remove dashes (-) from a phone number

SELECT
'123-456-7890' 'PHONE_NO', 
REPLACE('123-456-7890', '-', '/') AS clean_phone

-- Replace File Existence from txt to csv

SELECT
'report.txt' old_filename,
REPLACE('report.txt', '.txt', '.csv') new_filename


-- LEN -> Counts how many characters you have in a value

-- TASK
-- Calculate the length of each customer's name

SELECT 
first_name,
Len(first_name) len_first_name
FROM customers

-- LEFT & RIGHT -> Left extracts specific number of characters from the start and right does the opposite

-- TASK
-- Retrieve the first two characters of each first name

SELECT
first_name,
LEFT(TRIM(first_name), 2) first_2_char
FROM customers

-- TASK
-- Retrieve the LAST two characters of each first name

SELECT
first_name,
RIGHT(TRIM(first_name), 2) first_2_char
FROM customers


-- SUBSTRING -> Extracts a part of a string at a specified position

-- TASK
-- Retrieve a list of customers first names removing the first character

SELECT
first_name,
SUBSTRING(TRIM(first_name), 2, LEN(first_name)) removed_1st_char
FROM customers



-- * Number Func

-- ROUND 

SELECT
3.516 'number',
ROUND(3.516, 2) AS round_2dp,
ROUND(3.516, 1) AS round_1dp,
ROUND(3.516, 0) AS round_0dp

-- ABS -> Converts any -ve no to a +ve number

SELECT
-10 'number',
ABS(-10) negative_no,
ABS(10) positive_no




-- * Date & Time Func 

SELECT 
OrderId,
CreationTime, 
'2025-08-20' HardCoded,
GETDATE() Today
FROM Sales.Orders

/*
	GetDate Function -> Returns the current date and time at the moment
	when the query is executed.

	Date & Time functions include:
	1. DAY	-> Returns the day from a date: DAY(date)
	2. MONTH	-> Returns the month from a date: MONTH(date)
	3. YEAR	-> Returns the year from a date: YEAR(date)
	4. DATEPART -> returns specific part of the date as a number.
	5. DATENAME -> returns the name of a specific part of a date.
	6. DATETRUNC -> Truncates the date to the specific part.
	7. EOMONTH -> returns the last day of a month.
	8. FORMAT
	9. CONVERT
	10. CAST ->
	11. DATEADD
	12. DATEDIFF
	13. ISDATE
*/ 

SELECT 
OrderId,
CreationTime, 
YEAR(CreationTime) Year,
MONTH(CreationTime) Month,
DAY(CreationTime) Day,
DATEPART(year, CreationTime) datepart_year,
DATEPART(month, CreationTime) datepart_month,
DATEPART(day, CreationTime) datepart_day,
DATEPART(hour, CreationTime) datepart_hour,
DATEPART(week, CreationTime) datepart_week,
DATENAME(month, CreationTime) datename_month,
DATENAME(weekday, CreationTime) datename_weekday,
DATETRUNC(minute, CreationTime) datetrunc_minute,
-- DATETRUNC Examples
DATETRUNC(hour, CreationTime) datetrunc_hour,
DATETRUNC(day, CreationTime) datetrunc_day,
DATETRUNC(year, CreationTime) datetrunc_year,
-- EOMONTH Example
EOMONTH(CreationTime) endOfMonth,
-- CAST Example
CAST(DATETRUNC(month, CreationTime) AS DATE) startOfMonth
FROM Sales.Orders

-- TASK
-- Show the number of orders which were made in each month

SELECT
DATETRUNC(month, CreationTime),
COUNT(*)
FROM Sales.Orders
GROUP BY DATETRUNC(month, CreationTime)

-- TASK
-- How many orders were placed each year?

SELECT
YEAR(OrderDate) year,
COUNT(*) noOfOrders
FROM Sales.Orders
GROUP BY OrderDate --5:58:36


