USE MyDatabase;

-- Retrieve All customer data
SELECT 
*
FROM customers;

GO

-- Retrieve All order data

SELECT *
FROM orders;

-- Retrieve EACH customer name, country, and score

SELECT
	first_name,
	country,
	score
FROM customers;

-- Retrieve all customers with scores of 500 and above.
SELECT *
FROM customers
WHERE score >= 500;


-- Retrieve all customers from Germany

SELECT * 
FROM customers
WHERE country = 'Germany';

-- Retrieve all customers in ascending order of there scores and are from Germany.

SELECT *
FROM customers
WHERE country = 'Germany'
ORDER BY score ASC;

-- Retrieve all customers and sort the results by the highest score first

SELECT *
FROM customers
ORDER BY score DESC;

-- Retrieve all customers and sort the results y the country and then by the highest score

SELECT *
FROM customers
ORDER BY country ASC,
 	score DESC;

GO

-- Find the total score for each country.

SELECT 
country,
SUM(score) AS total_score
FROM customers
GROUP BY country;

-- Find the total score and total number of customers for each country

SELECT 
	country,
	SUM(score),
	COUNT(id) AS total_customers
FROM customers
GROUP BY country;
	
-- Find the average score for each country considering only customers with a score not equal to 0

SELECT 
	country,
	AVG(score) AS avg_score
FROM customers
where score != 0
GROUP BY country;



/* Find the average score for each country
	considering only customers with a score not equal to 0
	and return only those with an average score greater than 430
*/

SELECT 
	country,
	AVG(score) AS total_score
FROM customers
WHERE score != 0
GROUP BY country
HAVING AVG(score) > 430;

-- Return unique list of all countries.

SELECT DISTINCT
	country
FROM customers;

-- Retrieve the Top 3 customers.
SELECT TOP 3 *	
FROM customers;

-- Retrieve the Top 3 customers with the highest score

SELECT TOP 3 *
FROM customers
ORDER BY score DESC;



-- Data Definition Language DDL

/*
	CREATE, ALTER & DROP
*/

-- Create a new table called persons with columns: id, person_name, birth_date, and phone.

CREATE TABLE persons (
id INT NOT NULL,
person_name VARCHAR(50) NOT NULL,
birth_date DATE,
phone VARCHAR(15) NOT NULL
CONSTRAINT pk_persons PRIMARY KEY (id)
)

-- Add a new column called email to the persons table

ALTER TABLE persons 
ADD	email VARCHAR(50) NOT NULL

-- Remove the column phone from the persons table

ALTER TABLE persons
DROP COLUMN phone

-- Delete the table persons from the database.

DROP TABLE persons



-- DATA MANIPULATION LANGUAGE DML

/*
	INSERT, UPDATE & DELETE
*/


INSERT INTO customers (id, first_name, country, score)
VALUES 
	(6, 'Anna', 'Kenya', NULL),
	(7, 'Anna', NULL, 100)

SELECT * FROM customers

-- Change the name Sam in id 6 to Anna.

UPDATE customers
SET first_name = 'Anna'
WHERE id = 6

-- Count all the number of customers we have in the table customers.

SELECT 
COUNT (*) FROM customers

-- Copy data from 'customers' table into 'persons'

INSERT INTO persons (id, person_name, birth_date, phone)
SELECT 
id, 
first_name AS  person_name,
NULL,
'Unknown'
FROM customers

-- Change the score of customer 7 to 0 and update the country to UK.

UPDATE customers
SET score = 0,
	country = 'UK'
WHERE id = 7

-- Update all customers with a NULL score by setting their score to 0

UPDATE customers
SET score = 0
WHERE score IS NULL


-- Delete all customers with an ID greater than 5

DELETE FROM customers
WHERE id > 5

select * from customers

-- Delete all from table persons

SELECT * FROM persons

DELETE FROM persons




/*

FILTERING DATA USING 'WHERE'
1. COMPARISON OPERATORS: =, <>, =!, >, >=, <, <=
2. LOGICAL OPERATORS: AND, OR NOT
3. RANGE OPERATOR: BETWEEN
4. MEMBERSHIP OPERATOR: IN, NOT IN
5. SEARCH OPERATOR: LIKE
2:09:24
*/

-- 1. COMPARISON OPERATOR

-- Retrieve all customers from Germany. =
SELECT *
FROM customers
WHERE country = 'Germany'

-- Retrieve all customers who are not from Germany. != or <>
SELECT *
FROM customers
WHERE country != 'Germany'

-- Retrieve all customers with a score greater than 500. >
SELECT *
FROM customers
WHERE score > 500

-- Retrieve all customers with a score of 500 or more. >=
SELECT *
FROM customers
WHERE score >= 500


-- 2. LOGICAL OPERATOR -> AND, OR, NOT

-- Retrieve all customers who are from the USA AND  have a score greater than 500. AND
SELECT *
FROM customers
WHERE country = 'USA' AND score > 500


-- Retrieve all customers who are either from the USA OR  have a score greater than 500. OR
SELECT *
FROM customers
WHERE country = 'USA' OR score > 500

-- Retrieve all customers with a score NOT less than 500. NOT
SELECT *
FROM customers
WHERE NOT score < 500



-- 2. RANGE OPERATOR -> BETWEEN

-- Retrieve all customers whose score falls in the range between 100 and 500
SELECT *
FROM customers
WHERE score BETWEEN 100 AND 500


-- 2. RANGE OPERATOR -> IN, NOT IN

-- Retrieve all customers from either Germany OR USA.

SELECT *
FROM customers
WHERE country IN ('Germany', 'USA')

-- Retrieve all customers who are not from either Germany OR USA.
SELECT *
FROM customers
WHERE country NOT IN ('Germany', 'USA')


-- 3. SEARCH OPERATOR -> LIKE

-- Find all customers whose first name starts with 'M'

SELECT *
FROM customers
WHERE first_name LIKE 'M%'

-- Find all customers whose first name ends with 'n'

SELECT *
FROM customers
WHERE first_name LIKE '%n'


-- Find all customers whose first name contains 'r'

SELECT *
FROM customers
WHERE first_name LIKE '%r%'


-- Find all customers whose first name has 'r' in the third position

SELECT *
FROM customers
WHERE first_name LIKE '__r%'


/*
	COMBINING DATA FROM MULTIPLE TABLES: JOINS & SET OPERATORS

	SQL JOINS
	1. INNER JOIN
	2. LEFT JOIN
	3. RIGHT JOIN
	4. FULL JOIN
	
	ADVANCED CONCEPTS

	5. LEFT ANTI JOIN
	6. RIGHT ANTI JOIN
	7. FULL ANTI JOIN 
	8. CROSS JOIN
*/


-- Retrieve all data from customers and orders as separate results

SELECT TOP(2) * 
FROM customers

SELECT TOP(2) * 
FROM orders

-- 1. INNER JOIN -> Returns only the matching data from both tables

-- Get all customers along with their orders, but only for customers who have placed an order.

SELECT 
	c.id,
	c.first_name,
	c.country,
	c.score,
	o.order_id,
	o.order_date,
	o.sales
FROM customers AS c
INNER JOIN orders AS o
ON id = customer_id;


-- 2. LEFT JOIN -> Returns all rows from left and only matching from right.

-- Get all customers along with their orders, including those without orders.

SELECT 
c.id,
c.first_name,
c.country,
c.score,
o.order_id,
o.order_date,
o.sales
FROM customers AS c
LEFT JOIN orders AS o
ON id = customer_id

-- 3. RIGHT JOIN -> Returns all rows from right and only matching from left.

-- Get all customers along with their orders, including orders without matching customers.

SELECT *
FROM customers
RIGHT JOIN orders
ON id = customer_id


-- 4. FULL JOIN -> Returns all rows from BOTH tables.

-- Get all customers and all orders, even if there's no match

SELECT *
FROM customers
FULL JOIN orders
ON id = customer_id


-- ADVANCED JOINS

-- 1. LEFT ANTI JOIN -> Returns rows from left that has no match in right

-- Get all customers who haven't placed any order.

SELECT *
FROM customers
LEFT JOIN orders
ON id = customer_id
WHERE customer_id IS NULL

-- 2. FULL ANTI JOIN -> Returns ONLY rows that don't match in either tables

-- Find customers without orders and orders without customers.

SELECT *
FROM customers
FULL JOIN orders
ON id = customer_id
WHERE id IS NULL OR customer_id IS NULL

/*
	CHALLENGE
	Get all customers along with their orders, but only for customers 
	who have placed an order without using INNER JOIN

*/

SELECT * 
FROM customers
LEFT JOIN orders
ON id = customer_id
WHERE customer_id IS NOT NULL


-- 3. CROSS JOIN -> Combines every row from left with every row from right. All possible combinations (Cartesian Join)
				

-- Generate all possible combinations of customers and orders.

SELECT * 
FROM customers
CROSS JOIN orders


-- CHALLENGE
/*
-- Using the SalesDB, retrieve a list of all orders, along with the related customer, product, and employee details.
	For each order, display:
		1.Order ID
		2.Customer Name
		3.Product Name
		4.Sales
		5.Price
		6.Sales Person Name
*/
-- SOLUTION

USE SalesDB

SELECT *
FROM Sales.Orders

SELECT *
FROM Sales.Customers

SELECT *
FROM Sales.Products

SELECT *
FROM Sales.Employees

SELECT 
	O.OrderID,
	O.Sales,
	C.FirstName AS CustomerName,
	P.Product,
	P.Price,
	E.FirstName AS SalesPerson
FROM Sales.Orders AS O
LEFT JOIN Sales.Customers AS C
ON O.CustomerID = C.CustomerID
LEFT JOIN Sales.Products AS P
ON O.ProductID = P.ProductID
LEFT JOIN Sales.Employees AS E
ON O.SalesPersonID = E.EmployeeID



/* 
	SET OPERATORS -> Combining Rows

	TYPES
	1. UNION
	2. UNION ALL
	3. EXCEPT (Minus)
	4. INTERSECT

	NB: # NO.of columns has to be the same
		# The data types of each column in each query must match
		# Have the same number of columns and in the same order
		# The column names in the result set are determined by the column names specified in the first query.
		# ORDER BY can be used only once
		# Ensure that you are mapping correct columns

*/

-- EXAMPLE

-- 1. UNION -> Returns all distinct rows from both queries and removes duplicate rows from the result.

SELECT
FirstName,
LastName
FROM Sales.Customers
UNION
SELECT
FirstName,
LastName
FROM Sales.Employees

-- TASK
-- Combine the data from employees and customers into one table.

SELECT 
	FirstName,
	LastName
FROM Sales.Customers
UNION
SELECT 
	FirstName,
	LastName
FROM Sales.Employees

-- 2. UNION ALL -> Returns all rows from both queries including duplicates.
-- Combine the data from employees and customers into one table, including duplicates.

SELECT 
	FirstName,
	LastName
FROM Sales.Customers
UNION ALL
SELECT 
	FirstName,
	LastName
FROM Sales.Employees

-- 3. EXCEPT -> Returns all distinct rows from the first query that are not found in the second query.
-- Find employees who are not customers at the same time.

SELECT 
	FirstName,
	LastName
FROM Sales.Employees
EXCEPT
SELECT 
	FirstName,
	LastName
FROM Sales.Customers

-- 4. INTERSECT -> Returns ONLY the rows that are common in both queries.
-- Find employees who are also customers.

SELECT 
	FirstName,
	LastName
FROM Sales.Employees
INTERSECT
SELECT 
	FirstName,
	LastName
FROM Sales.Customers

/*
	TASK
	=> Orders are stored in separate tables
	(Orders and OrdersArchive).
	Combine all orders into one report without duplicates
*/

-- SOLUTION
SELECT 
'Orders' AS SourceTable,
	OrderID,
	ProductID,
	CustomerID,
	SalesPersonID,
	OrderDate,
	ShipDate,
	OrderStatus,
	ShipAddress,
	BillAddress,
	Quantity,
	Sales,
	CreationTime
FROM Sales.Orders
UNION 
SELECT 
'OrdersArchive' AS SourceTable,
	OrderID,
	ProductID,
	CustomerID,
	SalesPersonID,
	OrderDate,
	ShipDate,
	OrderStatus,
	ShipAddress,
	BillAddress,
	Quantity,
	Sales,
	CreationTime
FROM Sales.OrdersArchive
ORDER BY OrderID


/*

	SQL FUNCTIONS
	-> They are built-in functions that accepts an input
	   value, process it, and returns an output 
	   value

	TYPES OF SQL FUNCTIONS:

	1. ROW-LEVEL FUNCTIONS
	2. AGGREGATION & ANALYTICAL FUNCTIONS


	1. ROW-LEVEL FUNCTIONS ->
		* String Func
		* Number Func
		* Date & Time Func
		* Null Func
		* Case Statement

*/

-- * String Func

-- CONCAT -> Combines multiple strings into one

-- TASK

-- Concatenate first name and country into one column

SELECT 
first_name,
country,
CONCAT(first_name, ' ', country) AS Name_Country
FROM customers

-- LOWER & UPPER -> Converts all characters to upper and vice-versa

-- TASK 
-- Convert the first names of customers to lowercase

SELECT
first_name,
LOWER(first_name) AS LowerName,
country
FROM customers

-- TASK 
-- Convert the first names of customers to uppercase

SELECT
first_name,
UPPER(first_name) AS UpperName,
country
FROM customers

-- TRIM -> Removes leading and trailing spaces
-- TASK
-- Find customers whose first name contains leading or trailing spaces

SELECT 
first_name
FROM customers
WHERE first_name != TRIM(first_name)

-- You can also solve the same problem by finding the length of the names

SELECT 
first_name,
LEN(first_name) AS Len_Names,
LEN(TRIM(first_name)) AS TrimmedNamesLen
FROM customers


-- REPLACE -> Replace specific character with a new character

-- TASK
-- Remove dashes (-) from a phone number

SELECT
'123-456-7890' 'PHONE_NO', 
REPLACE('123-456-7890', '-', '/') AS clean_phone

-- Replace File Existence from txt to csv

SELECT
'report.txt' old_filename,
REPLACE('report.txt', '.txt', '.csv') new_filename


-- LEN -> Counts how many characters you have in a value

-- TASK
-- Calculate the length of each customer's name

SELECT 
first_name,
Len(first_name) len_first_name
FROM customers

-- LEFT & RIGHT -> Left extracts specific number of characters from the start and right does the opposite

-- TASK
-- Retrieve the first two characters of each first name

SELECT
first_name,
LEFT(TRIM(first_name), 2) first_2_char
FROM customers

-- TASK
-- Retrieve the LAST two characters of each first name

SELECT
first_name,
RIGHT(TRIM(first_name), 2) first_2_char
FROM customers


-- SUBSTRING -> Extracts a part of a string at a specified position

-- TASK
-- Retrieve a list of customers first names removing the first character

SELECT
first_name,
SUBSTRING(TRIM(first_name), 2, LEN(first_name)) removed_1st_char
FROM customers



-- * Number Func

-- ROUND 

SELECT
3.516 'number',
ROUND(3.516, 2) AS round_2dp,
ROUND(3.516, 1) AS round_1dp,
ROUND(3.516, 0) AS round_0dp

-- ABS -> Converts any -ve no to a +ve number

SELECT
-10 'number',
ABS(-10) negative_no,
ABS(10) positive_no




-- * Date & Time Func 

SELECT 
OrderId,
CreationTime, 
'2025-08-20' HardCoded,
GETDATE() Today
FROM Sales.Orders

/*
	GetDate Function -> Returns the current date and time at the moment
	when the query is executed.

	Date & Time functions include:
	1. DAY	-> Returns the day from a date: DAY(date)
	2. MONTH	-> Returns the month from a date: MONTH(date)
	3. YEAR	-> Returns the year from a date: YEAR(date)
	4. DATEPART -> returns specific part of the date as a number.
	5. DATENAME -> returns the name of a specific part of a date.
	6. DATETRUNC -> Truncates the date to the specific part.
	7. EOMONTH -> returns the last day of a month.
	8. FORMAT -> Changing the format of a value from one to another. Changing how the data looks like.
	9. CONVERT -> Converts a date or time value to a different data type.
	10. CAST -> changing the data type from one to another.
	11. DATEADD -> Adds or subtracts a specific time interval to/from a date.
	12. DATEDIFF -> Find the differences between two dates.
	13. ISDATE -> Check if a value is a date. Returns 1 if the string value is a valid date.
*/ 

SELECT 
OrderId,
CreationTime, 
YEAR(CreationTime) Year,
MONTH(CreationTime) Month,
DAY(CreationTime) Day,
DATEPART(year, CreationTime) datepart_year,
DATEPART(month, CreationTime) datepart_month,
DATEPART(day, CreationTime) datepart_day,
DATEPART(hour, CreationTime) datepart_hour,
DATEPART(week, CreationTime) datepart_week,
DATENAME(month, CreationTime) datename_month,
DATENAME(weekday, CreationTime) datename_weekday,
DATETRUNC(minute, CreationTime) datetrunc_minute,
-- DATETRUNC Examples
DATETRUNC(hour, CreationTime) datetrunc_hour,
DATETRUNC(day, CreationTime) datetrunc_day,
DATETRUNC(year, CreationTime) datetrunc_year,
-- EOMONTH Example
EOMONTH(CreationTime) endOfMonth,
-- CAST Example
CAST(DATETRUNC(month, CreationTime) AS DATE) startOfMonth
FROM Sales.Orders

-- TASK
-- Show the number of orders which were made in each month

SELECT
DATETRUNC(month, CreationTime),
COUNT(*)
FROM Sales.Orders
GROUP BY DATETRUNC(month, CreationTime)

-- TASK
-- How many orders were placed each year?

SELECT
YEAR(OrderDate) year,
COUNT(*) noOfOrders
FROM Sales.Orders
GROUP BY YEAR(OrderDate)

-- TASK
-- How many orders were placed each month?

SELECT
DATENAME(month, OrderDate) Month,
COUNT(*) NoOfOrders
FROM Sales.Orders
GROUP BY DATENAME(month, OrderDate)

-- Show all the orders that were placed during the month of february

SELECT
*
FROM Sales.Orders
WHERE MONTH(OrderDate) = 2

-- FORMAT()

SELECT
OrderID,
CreationTime,
FORMAT(CreationTime, 'dd') dd,
FORMAT(CreationTime, 'ddd') ddd,
FORMAT(CreationTime, 'dddd') dddd,
FORMAT(CreationTime, 'MM') MM,
FORMAT(CreationTime, 'MMM') MMM,
FORMAT(CreationTime, 'MMMM') MMMM,
-- EUROPE FORMAT
FORMAT(CreationTime, 'dd-MMM-yyyy') Europe_Format
FROM Sales.Orders

-- TASK
-- Show CreationTime using the following format: Day Wed Jan Q1 2025 12:34:56 PM


-- SOLUTION
SELECT
CreationTime,
FORMAT(CreationTime, 'dd') +' ' + 
FORMAT(CreationTime, 'ddd') +' ' + 
FORMAT(CreationTime, 'MMM') +' ' + 
'Q1' +' ' + 
FORMAT(CreationTime, 'yyyy') +' ' + 
FORMAT(CreationTime, 'hh:mm:ss: tt') Custom_Format
FROM Sales.Orders

-- CONVERT()

 SELECT
	 CONVERT(INT, '123') AS [String to Int CONVERT],
	 CONVERT(DATE, '2025-08-20') AS [String to DATE CONVERT],
	 CreationTime,
	 CONVERT(DATE, CreationTime) AS [Datetime to Date CONVERT]
 FROM Sales.Orders


 --  DATEADD ->

 SELECT 
 OrderID,
 OrderDate,
 -- year
 DATEADD(year, 2, OrderDate) added_2yrs,
 DATEADD(year, -5, OrderDate) subtracted_5yrs,
 -- months
 DATEADD(month, 3, OrderDate) added_3months,
 DATEADD(month, -1, OrderDate) subtracted_1month,
 -- date
 DATEADD(day, 2, OrderDate) added_2days,
 DATEADD(day, -5, OrderDate) subtracted_5days
 FROM Sales.Orders


 -- DATEDIFF()
 -- TASK

 -- Calculate the age of employees

 SELECT 
 EmployeeID,
 FirstName,
 BirthDate,
 DATEDIFF(year, BirthDate, GETDATE()) AS Age
 FROM Sales.Employees


  -- TASK

 -- Find the average shipping duration in days for each month

 SELECT 
 MONTH(OrderDate)AS OrderDate,
 AVG(DATEDIFF(day, OrderDate, ShipDate)) AvgShip
 FROM Sales.Orders
 GROUP BY  MONTH(OrderDate)


 -- ISDATE()

 SELECT 
 ISDATE('123') DateCheck1,
 ISDATE('2025-08-20') DateCheck2;


 /*
 
	NULL FUNCTIONS
	-> NULL means nothing, unknown!
	
	FUNCTIONS TO HANDLE NULL:
	1. ISNULL -> Replaces 'NULL' with a specified value
	2. COALESCE -> Used to replace NULL with something, can be a 0 or a string
	3. NULLIF -> Compares two expressions returns: NULL, if they are equal, FIRST VALUE, if they are not equal
	4. IS NULL -> returns true if the value is null otherwise false
	5. IS NOT NULL -> returns truw if the value is not null
 
 */

 -- 2. COALESCE
 -- Find the average scores of the customers

SELECT
	CustomerID,
	Score,
	COALESCE(Score, 0) Score2, -- ->This replaces the NULL with a 0
	AVG(Score) OVER () AvgScore,
	AVG(COALESCE(Score, 0)) OVER () AvgScore2
FROM Sales.Customers

-- Display the full name of customers in a single field
-- by merging their first and last names,
-- and add 10 bonus points to each customer's score.

-- SOLUTION

SELECT *
FROM Sales.Customers


SELECT
CustomerID,
FirstName + ' ' + COALESCE(LastName, '') AS FullName,
Score,
COALESCE(Score, 0) + 10 ScoreBonus
FROM Sales.Customers


-- 3. NULLIF(value1, value2) -> Commonly used to prevent dividing by a zero

-- Find the sales price for each order by dividing sales by quantity

SELECT
OrderID, 
Sales,
Quantity,
Sales /NULLIF(Quantity, 0) sales_price -- we NULLIF to make quantity 0 so that we can do the division since you can't divide by a 0
FROM Sales.Orders


-- 4. IS NULL ->

-- Identify the customers who have no scores

SELECT
CustomerID,
FirstName,
Score
FROM Sales.Customers
WHERE Score IS NULL

-- List all customers who have scores

SELECT
*
FROM Sales.Customers
WHERE Score IS NOT NULL

-- USE CASE FOR IS NULL & IS NOT NULL

-- List all details for customers who have not placed any orders

SELECT *
FROM Sales.Customers

SELECT *
FROM Sales.Orders

SELECT *
FROM Sales.Customers AS C
LEFT JOIN Sales.Orders AS O
ON C.CustomerID = O.CustomerID
WHERE OrderID IS NULL



/*

	CASE STATEMENT
	-> Evaluates a list of conditions and returns a value
	   when the first condition is met.

	   syntax:
	   CASE

		WHEN ... THEN
		WHEN ... THEN
		...

		ELSE result

	   END



	USE CASE:
	1. Main purpose is Data Transformations to derive new information without modifying the source infoin the DB.


*/

-- TASK

-- Generate a report showing the total sales for each category:
-- High: if the sales higher than 50
-- Medium: if the sales between 20 and 50
-- Low: if the sales equal or lower than 20
-- Sort the result from lowest to highest.

-- SOLUTION

SELECT
Category,
SUM(Sales) AS TotalSales
FROM(
	SELECT
	OrderID,
	Sales,
	CASE 
		WHEN Sales > 50 THEN 'High'
		WHEN Sales > 20 THEN 'Medium'

		ELSE 'Low'
	END Category
	FROM Sales.Orders
)t
GROUP BY Category
ORDER BY TotalSales DESC


-- Retrieve employee details with gender displayed as full text

SELECT 
EmployeeID,
FirstName,
Gender,
CASE
	WHEN Gender = 'M' THEN'Male'
	ELSE 'Female'
END full_gender
FROM Sales.Employees


/*

	AGGREGATION & ANALYTICAL FUNCTIONS

	* Aggregate Functions



*/

-- Find the total number of customers: COUNT()

SELECT
COUNT(*) total_orders
FROM orders

-- Find the total sales of all orders: SUM()

SELECT
SUM(Sales) total_sales
FROM orders

-- Find the average sales of all orders: AVG()

SELECT
AVG(Sales) average_sales
FROM orders

-- Find the highest sales of all orders: MAX()

SELECT
MAX(Sales) highest_sales
FROM orders

-- Find the lowest sales of all orders: MIN()

SELECT
MIN(Sales) lowest_sales
FROM orders



/*

	WINDOW FUNCTIONS
	- Perform calculations e.g aggregations on a specific subset
	  of data, without losing the level of details of rows.

*/


-- Find the total Sales for each product, additionally provide details such 
-- as order id & order date

SELECT 
ProductID,
Sales,
SUM(Sales) OVER(PARTITION BY ProductID) total_sales_by_products
FROM Sales.Orders

-- Rank each order based on their sales from highest to lowest,
-- additionally provide details such as order id & order date

SELECT
OrderID,
OrderDate,
Sales,
RANK() OVER (ORDER BY Sales DESC) RankSales
FROM Sales.Orders

-- 9:26:40 -> UPTO SUBQUERIES.






/*

	CTE (COMMON TABLE EXPRESSION)
	- Temporary, named result set (virtual table)
	  that can be used multiple times within 
	  your query to simplify and organize complex
	  query

	TYPES OF CTE:
	a. Non-Recursive CTE
	b. Recursive CTE

	a. Non-Recursive CTE
	   - It is only executed only once without any repetition
	TYPES:
		1. STANDALONE -> Defined and used independently 
						 in the query.

						 SYNTAX:

						 ;WITH CTE-Name AS
						 (
							SELECT ...
							FROM ...
							WHERE ...
						 )
		2. NESTED CTE -> CTE inside another CTE
		
						SYNTAX:

						 ;WITH CTE-Name1 AS
						 (
							SELECT ...
							FROM ...
							WHERE ...
						 )
						  ,CTE-Name2 AS
						 (
							SELECT ...
							FROM CTE-Name1 
							WHERE ...
						 )

						 -- Main Query
						 SELECT ...
						 FROM CTE-Name2 
						 WHERE ...

	b. Recursive CTE
	   - Self-referencing query that repeatedly
	     processes data until a specific condition is
		 met

		 SYNTAX:

		 ;WITH CTE-Name AS
						 (
							SELECT ...
							FROM ...
							WHERE ...
						 
							UNION ALL
						 
							SELECT ...
							FROM CTE-Name
							WHERE [Break Condition]
						 )




	Examples:
*/

-- Step1: Find the total Sales Per Customer

;WITH CTE_Total_Sales AS
(
SELECT
	CustomerID,
	SUM(Sales) AS TotalSales
FROM Sales.Orders
GROUP BY CustomerID
)
-- Step2: Find the last order date per customer
, CTE_Last_Order AS 
(
SELECT
	CustomerID,
	MAX(OrderDate) AS Last_Order
FROM Sales.Orders
GROUP BY CustomerID
)
-- Step3: Rank Customers based on total sales per customer.
, CTE_Customer_Rank AS 
(
SELECT
CustomerID,
TotalSales,
RANK () OVER (ORDER BY TotalSales DESC) AS CustomerRank
FROM CTE_Total_Sales

)
-- Step4: Segment customers based on their total sales.
, CTE_Customer_Segment AS 
(
SELECT
CustomerID,
TotalSales,
CASE WHEN TotalSales > 100 THEN 'High'
	 WHEN TotalSales > 80 THEN 'Medium'
	 ELSE 'Low'
END CustomerSegments
FROM CTE_Total_Sales
)
-- Main Query
SELECT
c.CustomerID,
c.FirstName,
c.LastName,
cts.TotalSales,
clo.Last_Order,
ccr.CustomerRank,
ccs.CustomerSegments
FROM Sales.Customers c
LEFT JOIN CTE_Total_Sales cts
ON cts.CustomerID = c.CustomerID
LEFT JOIN CTE_Last_Order clo
ON clo.CustomerID = c.CustomerID
LEFT JOIN CTE_Customer_Rank ccr
ON ccr.CustomerID = c.CustomerID
LEFT JOIN CTE_Customer_Segment ccs
ON ccs.CustomerID = c.CustomerID


-- Recursive CTE Examples
-- 1. Generate a sequence of numbers from 1 to 20

-- SOLUTION

;WITH Series AS 
(
	-- Anchor Query
	SELECT
	1 AS MyNumber
	UNION ALL
	-- Recursive Query
	SELECT
	MyNumber + 1
	FROM Series
	WHERE MyNumber < 20
)
-- Main Query
SELECT *
FROM Series
OPTION (MAXRECURSION 100) -- Specifies the no. of iterations b4 the loop breaks


-- 2. Show the employee hierachy by displaying each employee's level within the organization

;WITH CTE_Emp_Hierachy AS
(
	-- Anchor Query
	SELECT
		EmployeeID,
		FirstName,
		ManagerID,
		1 AS Level
	FROM Sales.Employees
	WHERE ManagerID IS NULL

	UNION ALL

	-- Recursive Query
	SELECT
		e.EmployeeID,
		e.FirstName,
		e.ManagerID,
		Level + 1
	FROM Sales.Employees AS e
	INNER JOIN CTE_Emp_Hierachy ceh
	ON e.ManagerID = ceh.EmployeeID
)

-- Main Query
SELECT
*
FROM CTE_Emp_Hierachy



/*
	VIEWS
	- Is a virtual table that shows data without storing
	  it physically.
	- Views are persisted SQL queries in the db

	SYNTAX:

	CREATE VIEW VIEW-NAME AS
	(
		SELECT ...
		FROM ...
		WHERE ...
	)

*/

-- Find the running total of sales for each month

;WITH CTE_Monthly_Summary AS
(
SELECT 
    MONTH(OrderDate) AS OrderMonth,
    SUM(Sales) AS TotalSalesEachMonth,
	COUNT(OrderID) TotalOrders,
	SUM(Quantity) TotalQuantities
FROM Sales.Orders
GROUP BY MONTH(OrderDate)
) 
SELECT
OrderMonth,
TotalSalesEachMonth,
SUM(TotalSalesEachMonth) OVER(ORDER BY OrderMonth) TotalRunningSales
FROM CTE_Monthly_Summary


-- Creating a view

CREATE VIEW Sales.V_MonthlySummary AS
(
SELECT 
    MONTH(OrderDate) AS OrderMonth,
    SUM(Sales) AS TotalSalesEachMonth,
	COUNT(OrderID) TotalOrders,
	SUM(Quantity) TotalQuantities
FROM Sales.Orders
GROUP BY MONTH(OrderDate)
)

-- Query From The View

SELECT *
FROM Sales.V_MonthlySummary


-- Lets create a view to the default schema dbo and try to drop it

CREATE VIEW V_Monthly_Summary AS
(
SELECT 
    MONTH(OrderDate) AS OrderMonth,
    SUM(Sales) AS TotalSalesEachMonth,
	COUNT(OrderID) TotalOrders,
	SUM(Quantity) TotalQuantities
FROM Sales.Orders
GROUP BY MONTH(OrderDate)
);

-- Dropping the view

DROP VIEW V_Monthly_Summary


-- Updating the view (we can use the Transact-SQL TO drop and re-create the view) T-SQL

IF OBJECT_ID('Sales.V_MonthlySummary', 'V') IS NOT NULL
	DROP VIEW Sales.V_MonthlySummary
GO

CREATE VIEW Sales.V_MonthlySummary AS
(
SELECT 
    MONTH(OrderDate) AS OrderMonth,
    SUM(Sales) AS TotalSalesEachMonth,
	COUNT(OrderID) TotalOrdersU,
	SUM(Quantity) TotalQuantities
FROM Sales.Orders
GROUP BY MONTH(OrderDate)
);

SELECT *
FROM Sales.V_MonthlySummary


/*
	USE CASE OF VIEWS
	1. HIDE COMPLEXITY, Protect data before sharing with other users.

		EXAMPLE BELOW.
*/

-- Provide a view that combines details from orders, products, customers, and employees

IF OBJECT_ID ('Sales.V_Sales_Summary_Details', 'V') IS NOT NULL
	DROP VIEW Sales.V_Sales_Summary_Details
GO

CREATE VIEW Sales.V_Sales_Summary_Details AS
(
SELECT 
O.[OrderID],
O.[ProductID],
O.[CustomerID],
O.[SalesPersonID],
O.[OrderDate],
O.[Quantity],
O.[Sales],
P.[Product],
P.[Category],
P.[Price],
COALESCE(C.FirstName, '') + ' ' + COALESCE(C.LastName, '') AS CustomerName,
C.Country,
C.Score,
COALESCE(E.FirstName, '')+ ' ' + COALESCE(E.LastName, '') AS EmployeeName,
E.Department,
E.Gender
FROM Sales.Orders O
LEFT JOIN  Sales.Products P
ON O.[ProductID] = P.ProductID
LEFT JOIN  Sales.Customers C
ON O.[CustomerID] = C.CustomerID
LEFT JOIN  Sales.Employees E
ON O.SalesPersonID = E.EmployeeID
)

-- Querying from the view:

SELECT *
FROM Sales.V_Sales_Summary_Details

/*
	USE CASE OF VIEWS
	2. Protect data before sharing with other users.

		EXAMPLE BELOW.
*/

-- Provide a view for EU Sales team, that combines details
-- from all tables and excludes data related to USA.

-- SOLUTION:

IF OBJECT_ID ('Sales.V_EU_Sales_Summary_Details', 'V') IS NOT NULL
	DROP VIEW Sales.V_EU_Sales_Summary_Details
GO

CREATE VIEW Sales.V_EU_Sales_Summary_Details AS
(
SELECT 
O.[OrderID],
O.[ProductID],
O.[CustomerID],
O.[SalesPersonID],
O.[OrderDate],
O.[Quantity],
O.[Sales],
P.[Product],
P.[Category],
P.[Price],
COALESCE(C.FirstName, '') + ' ' + COALESCE(C.LastName, '') AS CustomerName,
C.Country,
C.Score,
COALESCE(E.FirstName, '')+ ' ' + COALESCE(E.LastName, '') AS EmployeeName,
E.Department,
E.Gender
FROM Sales.Orders O
LEFT JOIN  Sales.Products P
ON O.[ProductID] = P.ProductID
LEFT JOIN  Sales.Customers C
ON O.[CustomerID] = C.CustomerID
LEFT JOIN  Sales.Employees E
ON O.SalesPersonID = E.EmployeeID
WHERE C.Country != 'USA'
);

SELECT * FROM Sales.V_EU_Sales_Summary_Details



/*
	
	CTAS Table (Create Table AS Select) & Temp Tables

		CTAS- Create a new table based on the result of an SQL query.

		- In the Normal method, you first create the table with 'CREATE'
		  which defines the structure of the table in the DB and then insert 
		  data later into the database.

		- But in CTAS you define the query, and once you execute the query
		  the DB has to retrieve the data from another table so it might retrieve
		  our data from the table we have created using the CREATE/INSERT OR another
		  table.

		- IN SIMPLE TERMS, CTAS excute the query and the data is ready to be consumed
		  no need of executing the query twice.

	    - Views are slower compared to CTAS, since views have to query the table again 
		  once executed.


		  SYNTAX:

		  CREATE/INSERT

		  CREATE TABLE Table-Name
		  (
			ID INT,
			Name VARCHAR (50)
		  )

		  INSERT INTO Table-Name
		  VALUES(1, 'Brian')



		  CTAS SYNTAX:

		  CREATE TABLE NAME AS
		  (
			SELECT ...
			FROM ...
			WHERE ...
		  )


*/


SELECT 
 DATENAME(month, OrderDate) OrderMonth,
 COUNT(OrderID) TotalOrder
INTO Sales.MonthlyOrders
FROM Sales.Orders
GROUP BY DATENAME(month, OrderDate)

SELECT * FROM Sales.MonthlyOrders;

-- DROP The CTAS 

DROP TABLE Sales.MonthlyOrders;

-- Refreshing the CTAS Table (We use T-SQL to drop and recreate the table)

IF OBJECT_ID('Sales.MonthlyOrders', 'U') IS NOT NULL
	DROP TABLE Sales.MonthlyOrders
GO 

SELECT 
 DATENAME(month, OrderDate) OrderMonth,
 COUNT(OrderID) TotalOrder
INTO Sales.MonthlyOrders
FROM Sales.Orders
GROUP BY DATENAME(month, OrderDate);


/*
	TEMPORARY TABLES
	- Stores intermediate results in temporary
	  storage within the database during the session

	- The db will drop all temp tables once the
	  session ends.


	  TEMP TABLE SYNTAX:

	  SELECT ...
	  INTO #New-Table
	  FROM ...
	  WHERE ...
*/

-- Created a temporary orders table
SELECT 
*
INTO #Orders
FROM Sales.Orders

-- Query from a temporary orders table

SELECT
*
FROM #Orders




/*
	
	STORED PROCEDURES
	- 

	SYNTAX:

	CREATE PROCEDURE ProceducreName AS
	BEGIN

		-- SQL STATEMENTS GOES HERE.

	END


	EXAMPLES BELOW:

*/

-- Step 1: Write a Query
-- For US Customers Find the total number of customers
-- and average score.


SELECT
	COUNT(*) TotalCustomers,
	AVG(Score) AvgScore
FROM Sales.Customers
WHERE Country = 'USA'

-- Step 2: Turn the above Query into a stored procedure.

CREATE PROCEDURE GetCustomerSummary AS
BEGIN
	SELECT
		COUNT(*) TotalCustomers,
		AVG(Score) AvgScore
	FROM Sales.Customers
WHERE Country = 'USA'

END

-- Step 3: Execute the Stored Procedure

EXEC GetCustomerSummary

-- PARAMETERS IN STORED PROCEDURES

-- TASK:

-- For German Customers find the total number of customers and the
-- average score

/*	SELECT
	COUNT(*) TotalCustomers, 
	AVG(Score) AvgScore
	FROM Sales.Customers
	WHERE Country = 'Germany'

	Instead of using the same query, we can use
	stored procedures to change the country parameter

*/

ALTER PROCEDURE GetCustomerSummaryGermany @Country NVARCHAR(50) = 'USA' 
AS
BEGIN
BEGIN TRY

	-- STORED PROCEDURE VARIABLES. 
	DECLARE @TotalCustomers INT
	DECLARE @AvgScore FLOAT;

	-- Prepare & Cleanup Data Using a CONTROL FLOW

	IF EXISTS (SELECT 1 FROM Sales.Customers WHERE Score IS NULL AND Country = @Country
	)
	BEGIN
		PRINT ('Updating NULL to 0.');
		UPDATE Sales.Customers
		SET Score = 0
		WHERE Score IS NULL AND Country = @Country
	END

	ELSE
	BEGIN
		PRINT ('No NULL Scores found!')
	END

	-- Generating Reports
	
		SELECT
			@TotalCustomers = COUNT(*),
			@AvgScore = AVG(Score)
		FROM Sales.Customers
		WHERE Country = @Country;

	PRINT 'Total Customers from ' + @Country + ':' + CAST(@TotalCustomers AS NVARCHAR);
	PRINT 'Average Score from ' + @Country + ':' + CAST(@AvgScore AS NVARCHAR);

	-- MULTIPLE QUERIES INSIDE 1 STORED PROCEDURE

	-- Find the total number of orders and total sales

	SELECT 
	COUNT(*) TotalOrders,
	SUM(Sales) TotalSales,
	1/0
	FROM Sales.Orders o
	JOIN Sales.Customers c
	ON c.CustomerID = o.CustomerID
	WHERE c.Country = @Country;
END TRY

BEGIN CATCH
	PRINT('An Error Occured!');
	PRINT('Error Message: ' + ERROR_MESSAGE());
	PRINT('Error Number: ' + CAST(ERROR_NUMBER() AS NVARCHAR));
	PRINT('Error Line: ' + CAST(ERROR_LINE() AS NVARCHAR));
	PRINT('Error Procedure: ' + ERROR_PROCEDURE());

END CATCH

END


EXEC GetCustomerSummaryGermany
EXEC GetCustomerSummaryGermany @Country = 'Germany'


/*

	TRIGGERS
	- They are special stored procedure (set of statements)
	  that automatically runs in response to a specific
	  event on a table or view.

	- Events that can occur on a table or view include:

	1. INSERT
	2. UPDATE
	3. DELETE

	TYPES OF TRIGGERS:
	- They can be 'AFTER' or 'INSTEAD OF' Triggers
	1. DML Triggers INSERT, UPDATE AND DELETE
	2. DDL Triggers CREATE, ALTER AND DROP
	3. LOGGON Triggers

	TRIGGER USECASE:
	- Audit Logs

	TRIGGER SYNTAX:

	CREATE TRIGGER TriggerName ON TableName
	AFTER INSERT, UPDATE, DELETE
	BEGIN
		SQL STATEMENTS GO HERE
	END


	EXAMPLE BELOW:
*/

SELECT * FROM Sales.Employees

-- Step1: Create Log Table

CREATE TABLE Sales.EmployeeLogs(
	LogID INT IDENTITY(1, 1) PRIMARY KEY,
	EmployeeID INT,
	LogMessage VARCHAR(255),
	LogDate DATE
)

-- Step2: Create Trigger on Employees Table

CREATE TRIGGER trg_AfterInsertEmlpoyee ON Sales.Employees
AFTER INSERT
AS
BEGIN
	INSERT INTO Sales.EmployeeLogs (EmployeeID, LogMessage, LogDate)
	SELECT
		EmployeeID,
		'New Employee Added: ' + CAST(EmployeeID AS NVARCHAR),
		GETDATE()
		FROM INSERTED  -- INSERTED is a virtual table that holds a copy of rows being inserted into the target table
		
END

-- Step3:  Insert New Data Into Employees

INSERT INTO Sales.Employees
VALUES
(7, 'Wiliam', 'Bosire', 'HR', '1988-01-12', 'M', 80000, 3)


-- Step4: Check the logs 
SELECT * FROM Sales.EmployeeLogs

/*

	PERFORMANCE OPTIMIZATION
	1. Indexes
		- Data structure that provides quick access to data,
		  otpimizing the speed of your queries.
		 
		 Categories of indexes:

		  i. structure
		  ii. storage
		  iii. functions


		  	 i. structure
			 - How db is organizing and referencing the data

		  Types of Indexes:

		  a. Clustered
		  b. Non-Clustered


		    ii. storage
			- How the data is stored physically in the db

		  Types of Indexes:

		  a. Rowstore Index
		  b. Columnstore Index


		    iii. functions

		  a. Unique Index
		  b. Filtered Index


	2. Partitons
	3. Performance Tips


	Index Syntax:

	CREATE [CLUSTERED | NONCLUSTERED] INDEX index_name ON table_name (column1, column2, ...)

	NB: By default if you do not explicitly mention the index, by default it will be nonclustered index.

	Examples Below:
*/

-- Copy the data from customer table into DBCustomer table
-- This table has no index therefore has a Heap Structure where it has to scan the whole data page.

SELECT *
INTO Sales.DBCustomers
FROM Sales.Customers

-- Create an index

CREATE CLUSTERED INDEX idx_DBCustostomers_CustomerID 
ON Sales.DBCustomers  (CustomerID);


-- To drop the index and create a new one on the different column we do

DROP INDEX idx_DBCustostomers_CustomerID
ON Sales.DBCustomers;

-- Example2
-- Lets say we mostly search a customer using the last name more frequently, we 
-- can create a nonclustered index to improve performance.

-- NONCLUSTERED INDEX
CREATE NONCLUSTERED INDEX idx_DBCustomers_LastName 
ON Sales.DBCustomers (LastName)


-- COMPOSITE INDEX -> Has multiple columns inside the same index

SELECT *
FROM Sales.DBCustomers
WHERE Country = 'USA' AND Score > 500

-- While creating the index and for it to work you should list those
-- columns as you have used them in your query. Country then Score.

CREATE INDEX idx_DBCustomers_CountryScore
ON Sales.DBCustomers (Country, Score)


-- COLUMNSTORE INDEX

CREATE CLUSTERED COLUMNSTORE INDEX idx_DBCustomer_CS
ON Sales.DBCustomers -- NB: You can't give the column name like CustomerID since we are dealing with column store

-- NB: You can't create a clustered and nonclustered column store you have to decide on
-- one or else drop one eg:

DROP INDEX idx_DBCustomer_CS
ON Sales.DBCustomers


-- Now we can create a nonclustered columnstore index with the desired columns

CREATE NONCLUSTERED COLUMNSTORE INDEX idx_DBCustomer_CS_FirstName
ON Sales.DBCustomers (FirstName)

-- UNIQUE CLUSTER

SELECT * FROM Sales.Products

-- Creating a unique index on the products table

CREATE UNIQUE NONCLUSTERED INDEX idx_Products_Category
ON Sales.Products (Category) -- we will get an error since duplicates in the columns will prevent creating a unique index

-- INDEX PERFORMANCE MANAGEMENT AND MONITORING.

-- List all indexes on a specific table

sp_helpindex 'Sales.DBCustomers'

-- Monitoring Index Usage.

SELECT 
	tbl.name AS TableName, 
	idx.name AS IndexName,
	idx.type_desc AS IndexType,
	idx.is_primary_key AS IsPrimaryKey,
	idx.is_unique AS IsUnique,
	idx.is_disabled AS IsDisabled,
	s.user_seeks,
	s.user_scans,
	s.user_lookups,
	s.user_updates,
	COALESCE(s.last_user_seek,s.last_user_scan) LastUpdate
FROM sys.indexes idx
JOIN sys.tables tbl
ON idx.object_id = tbl.object_id
LEFT JOIN sys.dm_db_index_usage_stats s
ON s.object_id = idx.object_id
AND s.index_id = idx.index_id
ORDER BY tbl.name, idx.name 


SELECT * FROM sys.dm_db_index_usage_stats

-- Monitor Missing Indexes
-- Fragmentation  By: Reorganize | Rebuild


-- EXECUTION PLAN

-- Is a roadmap generated by a db on how it will 
-- execute your query step by step.

USE AdventureWorksDW2022;

SELECT * 
INTO FactResellerSales_HEAP
FROM FactResellerSales;


SELECT * FROM FactResellerSales_HEAP




/*
	PARTITIONS
	- This is an SQL technique to divide big tables
	  into smaller partitions in order to optimize 
	  performance. 21:29:00
*/
